#!/bin/bash
# bashi - YAML-driven Bash test framework
# https://github.com/brooke-hamilton/bashi
# shellcheck source-path=SCRIPTDIR

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC2034
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Source library modules
# shellcheck source=lib/utils.sh
source "${SCRIPT_DIR}/lib/utils.sh"
# shellcheck source=lib/validator.sh
source "${SCRIPT_DIR}/lib/validator.sh"
# shellcheck source=lib/processor.sh
source "${SCRIPT_DIR}/lib/processor.sh"
# shellcheck source=lib/generator.sh
source "${SCRIPT_DIR}/lib/generator.sh"
# shellcheck source=lib/executor.sh
source "${SCRIPT_DIR}/lib/executor.sh"

# Version
VERSION="0.1.0"
# Schema version must match the version in src/bashi-schema.json
# Both are kept in sync manually to ensure compatibility
SCHEMA_VERSION="1.0.0"

# Default options
VALIDATE_ONLY=false
TIMEOUT=300
TAP_OUTPUT=false
TIMING=false
TRACE=false
NO_COLOR=false
PARALLEL_JOBS=1
INIT_MODE=false

# Arrays for multi-file support
TEST_SUITE_PATTERNS=()
TEST_SUITE_FILES=()

# Usage information
usage() {
    cat <<EOF
Usage: bashi [OPTIONS] <test-suite.bashi.yaml>...
       bashi [OPTIONS] <glob-pattern>...
       bashi --init

YAML-driven Bash test framework using Bats-core

OPTIONS:
    -h, --help              Show this help message
    --version               Show version information
    --init                  Create a new hello-world.bashi.yaml template in the current directory
    -v, --verbose           Enable verbose output
    --validate-only         Only validate the YAML schema, do not run tests
    -t, --tap               Output in TAP format instead of pretty print
    -T, --timing            Show timing information for each test
    -x, --trace             Print test commands as they are executed
    --timeout SECONDS       Set test execution timeout (default: 300)
    -j, --parallel [N]      Run tests in parallel with N jobs (default: CPU count)
    --no-color              Disable colored output (useful for testing)

GLOB PATTERNS:
    **/*.bashi.yaml         Match all .bashi.yaml files recursively
    tests/*.bashi.yaml      Match .bashi.yaml files in tests/ directory
    
EXAMPLES:
    bashi tests/my-suite.bashi.yaml
    bashi 'tests/**/*.bashi.yaml'
    bashi -j 4 'tests/**/*.bashi.yaml' 'docs/**/*.bashi.yaml'
    bashi --validate-only tests/my-suite.bashi.yaml

PARALLEL EXECUTION:
    When using -j/--parallel, test suites with 'parallel: false' in their
    YAML configuration will be run serially after parallel suites complete.

EXIT CODES:
    0   All tests passed
    1   One or more tests failed
    2   Invalid usage or missing dependencies

EOF
}

# Version information
version_info() {
    echo "bashi version ${VERSION}"
    echo "Schema version ${SCHEMA_VERSION}"
    echo "YAML-driven Bash test framework"
}

# Initialize a new hello-world.bashi.yaml template
init_template() {
    local output_file="hello-world.bashi.yaml"
    
    if [ -f "${output_file}" ]; then
        log_error "File already exists: ${output_file}"
        exit 1
    fi
    
    cat > "${output_file}" <<'EOF'
# yaml-language-server: $schema=https://raw.githubusercontent.com/brooke-hamilton/bashi/refs/heads/main/src/bashi-schema.json
# Hello World Bashi Test Suite
# A starter template for writing YAML-driven Bash tests
# See: https://github.com/brooke-hamilton/bashi

name: "Hello World Test Suite"

# Variables can be referenced in commands using {{variableName}} syntax
# variables:
#   greeting: "Hello"
#   target: "World"

# Lifecycle Hooks:
#   - setupFile:    Runs once before all tests (suite-wide setup)
#   - teardownFile: Runs once after all tests (suite-wide cleanup)
#   - setup:        Runs before each individual test
#   - teardown:     Runs after each individual test
#
# Variables exported in setupFile are available to all tests
# Use BATS_SUITE_TMPDIR for suite-wide temp files
# Use BATS_TEST_TMPDIR for per-test temp files

# setupFile: |
#   export MY_SUITE_VAR="suite-level-value"
#   echo "Suite setup complete" >&3

# teardownFile: |
#   echo "Suite teardown complete" >&3

# setup: |
#   export MY_TEST_VAR="test-level-value"

# teardown: |
#   # Cleanup per-test resources here
#   :

tests:
  - name: "Echo prints hello world"
    command: "echo 'Hello, World!'"
    exitCode: 0
    outputContains:
      - "Hello"
      - "World"

  - name: "Exit code validation works"
    command: "true"
    exitCode: 0

  # Uncomment the following test to see a failing test example:
  # - name: "Example failing test"
  #   command: "echo 'actual output'"
  #   exitCode: 0
  #   outputEquals: "expected output"
EOF

    echo "Created ${output_file}"
    echo "Run with: bashi ${output_file}"
}

# Parse command line arguments
parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            --version)
                version_info
                exit 0
                ;;
            --init)
                INIT_MODE=true
                shift
                ;;
            -v|--verbose)
                export BASHI_VERBOSE=true
                shift
                ;;
            --validate-only)
                VALIDATE_ONLY=true
                shift
                ;;
            -t|--tap)
                TAP_OUTPUT=true
                shift
                ;;
            -T|--timing)
                TIMING=true
                shift
                ;;
            -x|--trace)
                TRACE=true
                shift
                ;;
            --no-color)
                NO_COLOR=true
                shift
                ;;
            -j|--parallel)
                # Check if next arg is a number (optional argument)
                if [ $# -ge 2 ] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    PARALLEL_JOBS="$2"
                    shift 2
                else
                    # Default to CPU count
                    if command -v nproc >/dev/null 2>&1; then
                        PARALLEL_JOBS=$(nproc)
                    elif command -v sysctl >/dev/null 2>&1; then
                        PARALLEL_JOBS=$(sysctl -n hw.ncpu 2>/dev/null || echo 4)
                    else
                        PARALLEL_JOBS=4
                    fi
                    shift
                fi
                ;;
            --timeout)
                if [ $# -lt 2 ]; then
                    log_error "Option --timeout requires an argument"
                    exit 2
                fi
                TIMEOUT="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                usage >&2
                exit 2
                ;;
            *)
                # Positional argument - test suite file or glob pattern
                TEST_SUITE_PATTERNS+=("$1")
                shift
                ;;
        esac
    done
    
    # Handle --init mode
    if [ "${INIT_MODE}" = true ]; then
        # Validate that no other options or arguments were provided
        if [ "${VALIDATE_ONLY}" = true ] || [ "${TAP_OUTPUT}" = true ] || \
           [ "${TIMING}" = true ] || [ "${TRACE}" = true ] || \
           [ "${NO_COLOR}" = true ] || [ "${PARALLEL_JOBS}" -ne 1 ] || \
           [ "${TIMEOUT}" -ne 300 ] || [ "${BASHI_VERBOSE:-false}" = true ] || \
           [ ${#TEST_SUITE_PATTERNS[@]} -gt 0 ]; then
            log_error "--init cannot be combined with other options or arguments"
            exit 2
        fi
        init_template
        exit 0
    fi
    
    # Validate required arguments
    if [ ${#TEST_SUITE_PATTERNS[@]} -eq 0 ]; then
        log_error "No test suite file or pattern specified"
        usage >&2
        exit 2
    fi
    
    # Expand glob patterns to actual files
    local expanded_files
    if ! expanded_files=$(expand_glob_patterns "${TEST_SUITE_PATTERNS[@]}"); then
        exit 2
    fi
    
    # Convert to array
    while IFS= read -r file; do
        [ -n "${file}" ] && TEST_SUITE_FILES+=("${file}")
    done <<< "${expanded_files}"
}

# Main workflow
main() {
    parse_args "$@"
    
    # Set NO_COLOR environment variable if requested
    if [ "${NO_COLOR}" = true ]; then
        export NO_COLOR=1
    fi
    
    # Check dependencies
    check_dependencies || exit 2
    
    log_verbose "Found ${#TEST_SUITE_FILES[@]} test suite file(s)"
    
    # Step 1: Validate all YAML files exist and pass schema validation
    log_verbose "Step 1: Validating YAML schemas..."
    local file
    for file in "${TEST_SUITE_FILES[@]}"; do
        check_file_exists "${file}" || exit 2
        
        if ! validate_schema "${file}"; then
            log_error "Schema validation failed for: ${file}"
            exit 2
        fi
        log_verbose "  ✓ ${file}"
    done
    
    if [ "${VALIDATE_ONLY}" = true ]; then
        echo "✓ Schema validation passed for ${#TEST_SUITE_FILES[@]} file(s)"
        exit 0
    fi
    
    # Create shared temp directory for all generated bats files
    local temp_dir
    temp_dir=$(mktemp -d -t bashi.XXXXXX)
    
    # Ensure cleanup on exit, interrupt, or termination
    # shellcheck disable=SC2064
    trap "rm -rf '${temp_dir}'" EXIT INT TERM
    
    # Arrays to track parallel vs serial test files
    local parallel_bats_files=()
    local serial_bats_files=()
    
    # Step 2: Process each YAML file and generate Bats files
    log_verbose "Step 2: Processing YAML files and generating Bats tests..."
    local index=0
    for file in "${TEST_SUITE_FILES[@]}"; do
        log_verbose "  Processing: ${file}"
        
        # Process YAML and resolve variables
        local processed_data
        processed_data=$(process_test_suite "${file}")
        
        # Generate Bats test file
        local suite_name
        suite_name=$(yq eval '.name' "${file}")
        
        local bats_file="${temp_dir}/test_${index}.bats"
        echo "${processed_data}" | generate_bats_file "${suite_name}" "${bats_file}" "${TRACE}"
        
        # Check if suite allows parallel execution
        local parallel_setting
        parallel_setting=$(get_suite_parallel_setting "${file}")
        
        if [ "${parallel_setting}" = "true" ]; then
            parallel_bats_files+=("${bats_file}")
        else
            serial_bats_files+=("${bats_file}")
            log_verbose "    (marked for serial execution)"
        fi
        
        index=$((index + 1))
    done
    
    # Step 3: Execute tests
    log_verbose "Step 3: Executing tests..."
    local exit_code=0
    
    # Run parallel-safe suites together (if any)
    if [ ${#parallel_bats_files[@]} -gt 0 ]; then
        log_verbose "  Running ${#parallel_bats_files[@]} parallel-safe suite(s)..."
        if ! execute_bats_tests_batch "${TIMEOUT}" "${TAP_OUTPUT}" "${TIMING}" "${TRACE}" "${PARALLEL_JOBS}" "${parallel_bats_files[@]}"; then
            exit_code=$?
        fi
    fi
    
    # Run serial suites one at a time (if any)
    if [ ${#serial_bats_files[@]} -gt 0 ]; then
        log_verbose "  Running ${#serial_bats_files[@]} serial suite(s)..."
        for bats_file in "${serial_bats_files[@]}"; do
            if ! execute_bats_tests_batch "${TIMEOUT}" "${TAP_OUTPUT}" "${TIMING}" "${TRACE}" "1" "${bats_file}"; then
                local serial_exit=$?
                # Capture first failure exit code
                [ "${exit_code}" -eq 0 ] && exit_code="${serial_exit}"
            fi
        done
    fi
    
    # Cleanup handled by EXIT trap
    
    # Return combined exit code
    exit "${exit_code}"
}

# Run main
main "$@"
