#!/bin/bash
# bashi - YAML-driven Bash test framework
# https://github.com/brooke-hamilton/bashi
# shellcheck source-path=SCRIPTDIR

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC2034
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Source library modules
# shellcheck source=lib/utils.sh
source "${SCRIPT_DIR}/lib/utils.sh"
# shellcheck source=lib/validator.sh
source "${SCRIPT_DIR}/lib/validator.sh"
# shellcheck source=lib/processor.sh
source "${SCRIPT_DIR}/lib/processor.sh"
# shellcheck source=lib/generator.sh
source "${SCRIPT_DIR}/lib/generator.sh"
# shellcheck source=lib/executor.sh
source "${SCRIPT_DIR}/lib/executor.sh"

# Version
VERSION="0.1.0"

# Default options
VALIDATE_ONLY=false
TIMEOUT=300
TAP_OUTPUT=false
TIMING=false
TRACE=false
NO_COLOR=false
PARALLEL_JOBS=1

# Arrays for multi-file support
TEST_SUITE_PATTERNS=()
TEST_SUITE_FILES=()

# Usage information
usage() {
    cat <<EOF
Usage: bashi [OPTIONS] <test-suite.bashi.yaml>...
       bashi [OPTIONS] <glob-pattern>...

YAML-driven Bash test framework using Bats-core

OPTIONS:
    -h, --help              Show this help message
    -v, --version           Show version information
    --verbose               Enable verbose output
    --validate-only         Only validate the YAML schema, do not run tests
    -t, --tap               Output in TAP format instead of pretty print
    -T, --timing            Show timing information for each test
    -x, --trace             Print test commands as they are executed
    --timeout SECONDS       Set test execution timeout (default: 300)
    -j, --parallel [N]      Run tests in parallel with N jobs (default: CPU count)
    --no-color              Disable colored output (useful for testing)

GLOB PATTERNS:
    **/*.bashi.yaml         Match all .bashi.yaml files recursively
    tests/*.bashi.yaml      Match .bashi.yaml files in tests/ directory
    
EXAMPLES:
    bashi tests/my-suite.bashi.yaml
    bashi 'tests/**/*.bashi.yaml'
    bashi -j 4 'tests/**/*.bashi.yaml' 'docs/**/*.bashi.yaml'
    bashi --validate-only tests/my-suite.bashi.yaml

PARALLEL EXECUTION:
    When using -j/--parallel, test suites with 'parallel: false' in their
    YAML configuration will be run serially after parallel suites complete.

EXIT CODES:
    0   All tests passed
    1   One or more tests failed
    2   Invalid usage or missing dependencies

EOF
}

# Version information
version_info() {
    echo "bashi version ${VERSION}"
    echo "YAML-driven Bash test framework"
}

# Parse command line arguments
parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            --version)
                version_info
                exit 0
                ;;
            -v|--verbose)
                export BASHI_VERBOSE=true
                shift
                ;;
            --validate-only)
                VALIDATE_ONLY=true
                shift
                ;;
            -t|--tap)
                TAP_OUTPUT=true
                shift
                ;;
            -T|--timing)
                TIMING=true
                shift
                ;;
            -x|--trace)
                TRACE=true
                shift
                ;;
            --no-color)
                NO_COLOR=true
                shift
                ;;
            -j|--parallel)
                # Check if next arg is a number (optional argument)
                if [ $# -ge 2 ] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    PARALLEL_JOBS="$2"
                    shift 2
                else
                    # Default to CPU count
                    if command -v nproc >/dev/null 2>&1; then
                        PARALLEL_JOBS=$(nproc)
                    elif command -v sysctl >/dev/null 2>&1; then
                        PARALLEL_JOBS=$(sysctl -n hw.ncpu 2>/dev/null || echo 4)
                    else
                        PARALLEL_JOBS=4
                    fi
                    shift
                fi
                ;;
            --timeout)
                if [ $# -lt 2 ]; then
                    log_error "Option --timeout requires an argument"
                    exit 2
                fi
                TIMEOUT="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                usage >&2
                exit 2
                ;;
            *)
                # Positional argument - test suite file or glob pattern
                TEST_SUITE_PATTERNS+=("$1")
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [ ${#TEST_SUITE_PATTERNS[@]} -eq 0 ]; then
        log_error "No test suite file or pattern specified"
        usage >&2
        exit 2
    fi
    
    # Expand glob patterns to actual files
    local expanded_files
    if ! expanded_files=$(expand_glob_patterns "${TEST_SUITE_PATTERNS[@]}"); then
        exit 2
    fi
    
    # Convert to array
    while IFS= read -r file; do
        [ -n "${file}" ] && TEST_SUITE_FILES+=("${file}")
    done <<< "${expanded_files}"
}

# Main workflow
main() {
    parse_args "$@"
    
    # Set NO_COLOR environment variable if requested
    if [ "${NO_COLOR}" = true ]; then
        export NO_COLOR=1
    fi
    
    # Check dependencies
    check_dependencies || exit 2
    
    log_verbose "Found ${#TEST_SUITE_FILES[@]} test suite file(s)"
    
    # Step 1: Validate all YAML files exist and pass schema validation
    log_verbose "Step 1: Validating YAML schemas..."
    local file
    for file in "${TEST_SUITE_FILES[@]}"; do
        check_file_exists "${file}" || exit 2
        
        if ! validate_schema "${file}"; then
            log_error "Schema validation failed for: ${file}"
            exit 2
        fi
        log_verbose "  ✓ ${file}"
    done
    
    if [ "${VALIDATE_ONLY}" = true ]; then
        echo "✓ Schema validation passed for ${#TEST_SUITE_FILES[@]} file(s)"
        exit 0
    fi
    
    # Create shared temp directory for all generated bats files
    local temp_dir
    temp_dir=$(mktemp -d -t bashi.XXXXXX)
    
    # Arrays to track parallel vs serial test files
    local parallel_bats_files=()
    local serial_bats_files=()
    
    # Step 2: Process each YAML file and generate Bats files
    log_verbose "Step 2: Processing YAML files and generating Bats tests..."
    local index=0
    for file in "${TEST_SUITE_FILES[@]}"; do
        log_verbose "  Processing: ${file}"
        
        # Process YAML and resolve variables
        local processed_data
        processed_data=$(process_test_suite "${file}")
        
        # Generate Bats test file
        local suite_name
        suite_name=$(yq eval '.name' "${file}")
        
        local bats_file="${temp_dir}/test_${index}.bats"
        echo "${processed_data}" | generate_bats_file "${suite_name}" "${bats_file}" "${TRACE}"
        
        # Check if suite allows parallel execution
        local parallel_setting
        parallel_setting=$(get_suite_parallel_setting "${file}")
        
        if [ "${parallel_setting}" = "true" ]; then
            parallel_bats_files+=("${bats_file}")
        else
            serial_bats_files+=("${bats_file}")
            log_verbose "    (marked for serial execution)"
        fi
        
        ((index++)) || true
    done
    
    # Step 3: Execute tests
    log_verbose "Step 3: Executing tests..."
    local exit_code=0
    
    # Run parallel-safe suites together (if any)
    if [ ${#parallel_bats_files[@]} -gt 0 ]; then
        log_verbose "  Running ${#parallel_bats_files[@]} parallel-safe suite(s)..."
        if ! execute_bats_tests_batch "${TIMEOUT}" "${TAP_OUTPUT}" "${TIMING}" "${TRACE}" "${PARALLEL_JOBS}" "${parallel_bats_files[@]}"; then
            exit_code=$?
        fi
    fi
    
    # Run serial suites one at a time (if any)
    if [ ${#serial_bats_files[@]} -gt 0 ]; then
        log_verbose "  Running ${#serial_bats_files[@]} serial suite(s)..."
        for bats_file in "${serial_bats_files[@]}"; do
            if ! execute_bats_tests_batch "${TIMEOUT}" "${TAP_OUTPUT}" "${TIMING}" "${TRACE}" "1" "${bats_file}"; then
                local serial_exit=$?
                # Capture first failure exit code
                [ "${exit_code}" -eq 0 ] && exit_code="${serial_exit}"
            fi
        done
    fi
    
    # Cleanup temp directory
    rm -rf "${temp_dir}"
    
    # Return combined exit code
    exit "${exit_code}"
}

# Run main
main "$@"
